#!/usr/bin/env bash
tool_check() {
	type -P curl >/dev/null 2>&1 || { echo "ERROR:  curl required and not found"; exit 1; }
	type -P jq >/dev/null 2>&1 || { echo "ERROR:  jq required and not found"; exit 1; }
}
exitScript() { # $1=EXIT_REASON $2=EXIT_DETAILS
	[ "$1" == "USAGE" ] && {
		[ "$2" != "" ] && echo -e "ERROR: $2\n"
		echo -e "USAGE: $(echo $0 | sed -E 's#^.*/##') API_KEY SERVICE_ID FROM_DATE TO_DATE [--labels rows|cols] [--debug]"
		echo -e "       where FROM_DATE and TO_DATE are YYYY-MM-DD\n"
		echo -e "Note: The date range starts at FROM_DATE and goes through TO_DATE\n"
		exit 1
	}
	[ "$1" == "" ] && echo -e "$2" || echo -e "$1: $2"
	exit 0
}
checkJson() { # $1=JSON_TO_BE_CHECKED
	TEMP="$(echo $1 | jq -c '.')"
	[[ (("$TEMP" =~ ^\[)&&("$TEMP" =~ \]$))||(("$TEMP" =~ ^\{)&&("$TEMP" =~ \}$)) ]] || exitScript "ERROR" "$2"
}
callApi() { # $1=API_KEY $2=HTTP_METHOD $3=API_PATH $4=JSON_DATA
	((API_CALL_COUNT++))
	[ "$DEBUG" != "" ] && echo "DEBUG: API Call $API_CALL_COUNT: https://api.fastly.com$3"
	if [ "$#" -eq 3 ]; then
		OUTPUT=$(curl -q -s -g -X$2 -H "Fastly-Key: $1" "https://api.fastly.com$3")
	elif [ "$#" -eq 4 ]; then
		OUTPUT=$(curl -q -s -g -X$2 -H "Fastly-Key: $1" -H "Content-Type: application/vnd.api+json" -d "$4" "https://api.fastly.com$3")
	else
		exitScript "ERROR" "callApi expected 3 or 4 arguments and $# were found"
	fi
	checkJson "$OUTPUT" "API call \"$3\" failed"
	# The remaining lines are only relevant for paginated output
	CURRENT_PAGE=$(echo "$OUTPUT" | jq -r '.meta.current_page')
	NEXT_API_PATH=$(echo "$OUTPUT" | jq -r '.links.next' | sed -E 's/^https?:\/\/api\.fastly\.com//')
}
checkApiKey() {
	API_KEY=$1
	callApi "$API_KEY" "GET" "/current_customer"
	TEMP=$(echo "$OUTPUT" | jq -r '.name')
	[ "$TEMP" == "null" ] && exitScript "ERROR" "Bad API Key specified"
	[ "$DEBUG" != "" ] && echo "DEBUG: Customer Name for Supplied API Key = \"$TEMP\""
	CUSTOMER_NAME="$TEMP"
}
checkServiceId() {
	SERVICE_ID=$1
	[[ "$SERVICE_ID" =~ ^[0-9a-zA-Z]{21,22}$ ]] || exitScript  "ERROR" "Unexpected Characters Found in Service ID"
	callApi "$API_KEY" "GET" "/service/$SERVICE_ID"
	TEMP=$(echo "$OUTPUT" | jq -r '.name')
	[ "$TEMP" == "null" ] && exitScript "ERROR" "Bad Service ID specified"
	[ "$DEBUG" != "" ] && echo "DEBUG: Service Name for Supplied Service ID = \"$TEMP\""
	SERVICE_DETAILS="$OUTPUT"
}
getCustomerName() { # $1=SERVICE_DETAILS
	CUSTOMER_ID=$(echo "$1" | jq -r '.customer_id')
	callApi "$API_KEY" "GET" "/customer/$CUSTOMER_ID"
	CUSTOMER_NAME=$(echo "$OUTPUT" | jq -r '.name')
	[ "$DEBUG" != "" ] && echo "DEBUG: Customer ID for Supplied Service ID = \"$CUSTOMER_ID\""
	[ "$DEBUG" != "" ] && echo "DEBUG: Customer Name from Customer ID = \"$CUSTOMER_NAME\""
}
checkDateString() {
	# https://stackoverflow.com/questions/10759162/check-if-argument-is-a-valid-date-in-bash-shell
	[[ "$1" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || exitScript "ERROR" "$2 is not in expected YYYY-MM-DD format: \"$1\""
	TEST_DATE=$(date -v+1M -v-1M -jf "%F" "$1" +"%F" 2> /dev/null)
	[ "$DEBUG" != "" ] && echo "DEBUG: TEST_DATE result for $2 = \"$TEST_DATE\""
	[ "$1" != "$TEST_DATE" ] && exitScript "ERROR" "$2 is not a valid date: \"$1\""
	YEAR="$(echo "$1" | sed -E 's/^(....).*$/\1/')"
	[ "$DEBUG" != "" ] && echo "DEBUG: $2 year = \"$YEAR\""
	[[ "$YEAR" -lt 2011 ]] && exitScript "ERROR" "$2 predates Fastly's 2011 founding: \"$1\" :-)"
}
getEpoch() {
	TEMP="$(date -jf "%F" "$1" +"%s" 2> /dev/null)"
	[ "$TEMP" == "" ] && exitScript "ERROR" "Unable to convert $2 to epoch"
	echo "$TEMP"
}
setEndDate() {
	END_DATE="$(date -v+1d -jf "%F" "$1" +"%F" 2> /dev/null)"
	[ "$END_DATE" == "" ] && exitScript "ERROR" "Unable to set end date from $2"
	[ "$DEBUG" != "" ] && echo "DEBUG: END_DATE = \"$END_DATE\" ($2 + 1 day)"
}
checkDateRange() { 
	FROM_EPOCH="$(getEpoch $1 "FROM_DATE")"
	[ "$DEBUG" != "" ] && echo "DEBUG: FROM_DATE epoch = \"$FROM_EPOCH\""
	TO_EPOCH="$(getEpoch $2 "TO_DATE")"
	[ "$DEBUG" != "" ] && echo "DEBUG: TO_DATE epoch = \"$TO_EPOCH\""
	EPOCH_DIFFERENCE="$((TO_EPOCH-FROM_EPOCH))"
	[ "$DEBUG" != "" ] && echo "DEBUG: Seconds between TO_DATE and FROM_DATE = \"$EPOCH_DIFFERENCE\""
	[[ "$EPOCH_DIFFERENCE" < 0 ]] && exitScript "ERROR" "FROM_DATE is after TO_DATE: \"$1\" > \"$2\""
}
getStatBytesForService() { #$1=FIELD_NAME
	callApi "$API_KEY" "GET" "/stats/service/$SERVICE_ID/field/$1?from=$START_DATE&to=$END_DATE&by=day"
	STAT_BYTES="$(echo "$OUTPUT" | jq --arg FIELD "$1" '[.data[]|.[$FIELD]]|add')"
	[ "$STAT_BYTES" == "null" ] && STAT_BYTES=0
	[ "$DEBUG" != "" ] && echo "DEBUG: Total \"$1\" bytes = \"$STAT_BYTES\""
	echo "$OUTPUT" > "$1.json"
}
printBytes() { # $1 = #_OF_BYTES $2 = INCLUDE_BYTES
	[[ "$1" =~ ^[0-9]+$ ]] || exitScript "ERROR" "Non-numeric or negative byte value: \"$1\""
	LC_NUMERIC=en_US printf "%'.f" $1
	[ "$2" == "" ] && echo "" || {
		printf " byte"
		[[ "$1" =~ ^[0-9]+$ ]] && {
			[[ "$1" -ne 1 ]] && echo "s" || echo ""
		} || echo ""
	}
}
printAbbreviatedBytes() { # $1 = #_OF_BYTES
	[[ "$1" =~ ^[0-9]+$ ]] || exitScript "ERROR" "Non-numeric or negative byte value: \"$1\""
	BYTE_LENGTH="${#1}"
	[ "$DEBUG" != "" ] && echo "DEBUG: Byte length of $1 = $BYTE_LENGTH"	
	case "$BYTE_LENGTH" in
		1|2|3) POWER=0; UNIT="";  ;;
		4|5|6) POWER=1; UNIT="kilo";  ;;
		7|8|9) POWER=2; UNIT="mega";  ;;
		10|11|12) POWER=3; UNIT="giga";  ;;
		13|14|15) POWER=4; UNIT="tera";  ;;
		16|17|18) POWER=5; UNIT="peta";  ;;
		*) exitScript "ERROR" "Byte value is ginormous and most likely causing overflow problems: $1"
	esac
	UNIT_ABBREVIATION="$(echo "$UNIT" | tr '[:lower:]' '[:upper:]' | sed -E 's/^(.).*/\1/')"
	[ "$UNIT_ABBREVIATION" == "K" ] && UNIT_ABBREVIATION="k"
	[ "$DEBUG" != "" ] && echo "DEBUG: Byte value will be prettyprinted in ${UNIT}bytes (${UNIT_ABBREVIATION}b), i.e. BYTES/(1000**$POWER)"
	TEMP="$(echo "$1 / $((1000**$POWER))" | bc -l | sed -E 's/^(.*\....).*$/\1/' | sed -E 's/^\./0./' | sed -E 's/0*$//' | sed -E 's/\.$//')"
	[ "$TEMP" == "" ] && TEMP="0"
	echo "$TEMP ${UNIT_ABBREVIATION}B"
}
prettyPrintBytes() { # $1 = #_OF_BYTES
	[[ "$1" =~ ^[0-9]+$ ]] || exitScript "ERROR" "Non-numeric or negative byte value: \"$1\""
	BYTES="$(printBytes $1 1)"
	ABBREV_BYTES="$(printAbbreviatedBytes $1)"
	echo "$BYTES ($ABBREV_BYTES)"
}
# Main Code Starts Here
# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
POSITIONAL=()
while [[ $# -gt 0 ]]
do
	key="$1"
	case $key in
		-d|--debug)
			DEBUG="1"; shift ;;
		-l|--labels)
			LABELS="$2"; shift; shift ;;
		-s|--stop)
			STOP="1"; shift ;;
		*)    # unknown option
			POSITIONAL+=("$1"); shift ;;
	esac
done
set -- "${POSITIONAL[@]}" # restore positional parameters
#
[[ "$#" -eq 0 ]] && exitScript "USAGE"
[[ "$#" -ne 4 ]] && exitScript "USAGE" "4 arguments expected and $# found"
[[ "$LABELS" != "" ]] && {
	[[ ! "$LABELS" =~ ^r(ows?)?$ && ! "$LABELS" =~ ^c(ol((umn)?s?)?)?$ ]] && {
		exitScript "USAGE" "Unexpected value in optional --labels argument: \"$LABELS\""
	}
}
[[ "$STOP" != "" ]] && exitScript "INFO" "Script stopped by request"
#
tool_check
checkApiKey $1
checkServiceId $2
getCustomerName "$SERVICE_DETAILS"
checkDateString $3 "FROM_DATE"
checkDateString $4 "TO_DATE"
checkDateRange $3 $4
START_DATE="$3"
setEndDate $4 "TO_DATE"
getStatBytesForService "shield_resp_header_bytes"
[[ "$STAT_BYTES" -ne 0 ]] && {
	SHIELDING_FLAG="X"
	[[ "$DEBUG" -eq 1 ]] && echo "INFO: Origin Shielding is in use"
}
getStatBytesForService "bereq_header_bytes"
HEADER_BYTES="$STAT_BYTES"
getStatBytesForService "bereq_body_bytes"
BODY_BYTES="$STAT_BYTES"
TOTAL_BYTES=$((HEADER_BYTES+BODY_BYTES))
[[ "$LABELS" =~ ^r(ows?)?$ ]] && {
	echo "Total Bytes (Integer): $TOTAL_BYTES"
	echo "Total Bytes (Separated): $(printBytes "$TOTAL_BYTES")"
	echo "Total Bytes (Formatted): $(printAbbreviatedBytes $TOTAL_BYTES)"
	echo "Shielding: $SHIELDING_FLAG"
} || {
	[[ "$LABELS" =~ ^c(ol((umn)?s?)?)?$ ]] && echo "\"Total Bytes (Integer)\",\"Total Bytes (Separated)\",\"Total Bytes (Formatted)\",\"Shielding\""
	echo "$TOTAL_BYTES,\"$(printBytes "$TOTAL_BYTES")\",\"$(printAbbreviatedBytes $TOTAL_BYTES)\",\"$SHIELDING_FLAG\""
}